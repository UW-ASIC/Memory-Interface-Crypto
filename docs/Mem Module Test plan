# ================== MEM TOP-LEVEL VERIFICATION PLAN ==================
# Only use: host cmd/data bus (+ready/valid), ack bus, QSPI pins, vendor model.

# 1) Startup sequence
#    Stimulus:
#      - Apply reset, then just run clock until startup is expected to finish.
#    Check (via QSPI monitor OR vendor model state):
#      - See 66h → 99h (SW reset).
#      - See 06h → 98h (global unlock).
#      - See 06h → C7h/60h (chip erase).
#      - See repeated 05h reads until SR1.WIP == 0.
#      - See 35h read of SR2 and, if QE was 0, 06h + 31h write setting QE=1.
#      - Finally: flash contents all 0xFF, SR2.QE == 1, SR1.WIP == 0.

# 2) Basic functional read/write via host
# 2.1) AES write 128b + read back
#    - Host sends WR_RES(AES, addr=A), streams 16 known bytes data_aes[0..15].
#    - Observe correct ack_bus_request/ack_bus_id handshake.
#    - After done, host sends RD_TEXT(AES, addr=A), captures 16 bytes.
#    - Expect: readback == data_aes and vendor_mem[A..A+15] == data_aes.

# 2.2) SHA write 256b + read back
#    - Same as above, but WR_RES(SHA) / RD_TEXT(SHA) with 32-byte data_sha.
#    - Expect: readback == data_sha and vendor_mem[B..B+31] == data_sha.

# 2.3) AES key read 256b
#    - Preload vendor model key region with key[0..31].
#    - Host issues RD_KEY(AES) at that region.
#    - Capture 32 bytes on host bus; expect == key[].

# 3) Ack bus behaviour
#    For each op above (RD_KEY, RD_TEXT AES/SHA, WR_RES AES/SHA):
#      - ack_bus_request goes high AFTER all byte sent.
#      - ack_bus_id == MEM (2'b00).
#      - When TB asserts ack_bus_owned (arbiter grant), mem deassert ack_bus_request, clear id.

# 4) Busy / serialization (using WIP)
#    - Start long WR_RES(SHA 256b) at addr=B (requires WE + program + WIP poll).
#    - Before it finishes, host tries another command (e.g. RD_TEXT(AES) at C).
#    Check:
#      - QSPI monitor: no new read/program opcodes issued until SR1.WIP == 0.
#      - Host side: either second command is ignored, or is accepted but only
#        starts QSPI traffic after first op completes (according to spec).

# 5) Invalid / garbage commands
#    - Host sends random illegal headers (your invalid() generator).
#    Expect:
#      - No QSPI traffic (except in idle).
#      - No ack_bus_request (or defined error behaviour).
#      - Host never sees data on read side.

# 6) Random stress vs vendor-model scoreboard
#    - Maintain Python array expected_mem[] mirroring vendor model.
#    - Loop N times:
#        * Randomly choose one of:
#            - WR_RES AES 16B @ random aligned addr.
#            - WR_RES SHA 32B @ random aligned addr.
#            - RD_TEXT AES 16B.
#            - RD_TEXT SHA 32B.
#        * For WR: drive random data via host, update expected_mem.
#        * For RD: capture host data, compare to expected_mem slice.
#    - Host ready/valid randomized each byte. QSPI pins ONLY driven by mem.
#    - Pass if no mismatches and vendor model reports no errors.

# 7) Full smoke test (startup + normal ops)
#    - Reset, let startup FSM finish (reuse test 1 checks).
#    - Then:
#        * AES WR 128b + AES RD 128b compare.
#        * SHA WR 256b + SHA RD 256b compare.
#    - Ensures whole stack (CMD + FSM + QSPI + flash model) works end-to-end.
# 
#
#	For all tests not in qspi mode ensure only DI/DO pins being used
#	For all tests in qspi mode ensure  IO pins tri-stated when not use, driving tt uio_oe[3:0] pin individually
#
# =====================================================================
